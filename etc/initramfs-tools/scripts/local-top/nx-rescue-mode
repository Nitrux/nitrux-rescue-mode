#!/bin/sh

# SPDX-License-Identifier: BSD-3-Clause
# Copyright 2026 <Nitrux Latinoamericana S.C. <hello@nxos.org>>

PREREQ=""

prereqs() {
    echo "${PREREQ}"
}

case "$1" in
    prereqs) prereqs; exit 0 ;;
esac

# -- Source initramfs functions for logging
# shellcheck source=/dev/null
. /scripts/functions

# -- Begin real processing below this line

grep -q 'nx_rescue=1' /proc/cmdline || exit 0

# Display rescue mode banner
cat >/dev/console <<'EOF'

╔════════════════════════════════════════════════════════════════════════════╗
║                          NUTS RESCUE MODE                                  ║
╠════════════════════════════════════════════════════════════════════════════╣
║                                                                            ║
║  Initializing system recovery...                                           ║
║                                                                            ║
╚════════════════════════════════════════════════════════════════════════════╝

EOF

get_dev_by_label() {
  label="$1"
  i=0
  while [ "$i" -lt 30 ]; do
    dev="$(findfs "LABEL=$label" 2>/dev/null || true)"
    if [ -n "$dev" ] && [ -b "$dev" ]; then
      echo "$dev"
      return 0
    fi
    sleep 1
    i=$((i + 1))
  done
  return 1
}

printf '  ➜ Locating NX_HOME partition...\n' >/dev/console
HOME_DEV="$(get_dev_by_label NX_HOME)" || panic "NUTS Rescue: NX_HOME not found"
printf '  ✓ Found NX_HOME: %s\n' "$HOME_DEV" >/dev/console

printf '  ➜ Locating NX_ROOT partition...\n' >/dev/console
ROOT_DEV="$(get_dev_by_label NX_ROOT)" || panic "NUTS Rescue: NX_ROOT not found"
printf '  ✓ Found NX_ROOT: %s\n\n' "$ROOT_DEV" >/dev/console

[ "$HOME_DEV" != "$ROOT_DEV" ] || panic "NUTS Rescue: NX_HOME equals NX_ROOT"

# Verify NX_ROOT filesystem is XFS
printf '  ➜ Verifying filesystem types...\n' >/dev/console
ROOT_FS="$(blkid -s TYPE -o value "$ROOT_DEV" 2>/dev/null || echo "")"
if [ "$ROOT_FS" != "xfs" ]; then
  panic "NUTS Rescue: NX_ROOT filesystem is not XFS (found: $ROOT_FS)"
fi
printf '  ✓ NX_ROOT is XFS\n' >/dev/console

# Check for duplicate NX_ROOT labels to prevent restoring to the wrong drive
LABEL_COUNT="$(blkid -o device -t LABEL=NX_ROOT 2>/dev/null | wc -l)"
if [ "$LABEL_COUNT" -gt 1 ]; then
  panic "NUTS Rescue: Duplicate NX_ROOT labels detected ($LABEL_COUNT devices)"
fi
printf '  ✓ No duplicate labels detected\n\n' >/dev/console

# Wait for udev to settle
udevadm settle 2>/dev/null || sleep 2

# Load required filesystem modules
modprobe xfs 2>/dev/null || true
modprobe f2fs 2>/dev/null || true

# Detect filesystem type
HOME_FS="$(blkid -s TYPE -o value "$HOME_DEV" 2>/dev/null || echo "f2fs")"
printf '  ➜ Mounting NX_HOME (%s)...\n' "$HOME_FS" >/dev/console

mkdir -p /tmp/home

# Unmount if already mounted (shouldn't happen in initramfs, but be safe)
if grep -q "/tmp/home" /proc/mounts 2>/dev/null; then
  umount /tmp/home || panic "NUTS Rescue: failed to unmount /tmp/home"
fi

# Mount with detected filesystem type
if ! mount -o ro -t "$HOME_FS" "$HOME_DEV" /tmp/home; then
  panic "NUTS Rescue: mount NX_HOME failed ($HOME_DEV as $HOME_FS)"
fi

printf '  ✓ NX_HOME mounted (read-only)\n\n' >/dev/console

BACKUP_DIR="/tmp/home/.nuts/xfs"
BACKUP_FILE="$BACKUP_DIR/xfs-backup.xfs.zst"
CHECKSUM_FILE="$BACKUP_DIR/xfs-backup.md5sum"

if [ ! -f "$BACKUP_FILE" ]; then
  log_failure_msg "NUTS Rescue: backup file not found ($BACKUP_FILE)"
  log_failure_msg "NUTS Rescue: cannot proceed without backup, rebooting in 10 seconds"
  umount /tmp/home 2>/dev/null || true
  sleep 10
  reboot -f
fi

if [ ! -f "$CHECKSUM_FILE" ]; then
  log_failure_msg "NUTS Rescue: checksum file not found ($CHECKSUM_FILE)"
  log_failure_msg "NUTS Rescue: cannot proceed without checksum, rebooting in 10 seconds"
  umount /tmp/home 2>/dev/null || true
  sleep 10
  reboot -f
fi

printf '  ➜ Verifying backup integrity...\n' >/dev/console

EXPECTED_HASH="$(tail -n 1 "$CHECKSUM_FILE" 2>/dev/null | awk '{print $1}' || true)"
[ -n "$EXPECTED_HASH" ] || panic "NUTS Rescue: invalid checksum file"

ACTUAL_HASH="$(md5sum "$BACKUP_FILE" | awk '{print $1}' 2>/dev/null || true)"
[ -n "$ACTUAL_HASH" ] || panic "NUTS Rescue: md5sum failed"

[ "$EXPECTED_HASH" = "$ACTUAL_HASH" ] || panic "NUTS Rescue: integrity check failed"

printf '  ✓ Backup integrity verified\n\n' >/dev/console

printf '  ➜ Mounting NX_ROOT (read-write)...\n' >/dev/console

mkdir -p /tmp/root

# Unmount if already mounted (shouldn't happen in initramfs, but be safe)
if grep -q "/tmp/root" /proc/mounts 2>/dev/null; then
  umount /tmp/root || panic "NUTS Rescue: failed to unmount /tmp/root"
fi

# Try to mount the filesystem; if it fails due to corruption, reformat it
if ! mount -t xfs "$ROOT_DEV" /tmp/root 2>/dev/null; then
  cat >/dev/console <<'EOF'
  ! NX_ROOT filesystem is corrupted or damaged
  ! Reformatting partition to create clean filesystem...
EOF

  # Try to capture the old UUID before destroying it
  # If the filesystem is too corrupted, blkid might fail - that's OK
  OLD_UUID="$(blkid -s UUID -o value "$ROOT_DEV" 2>/dev/null || true)"

  # Wipe filesystem signature
  wipefs -a "$ROOT_DEV" >/dev/null 2>&1 || panic "NUTS Rescue: wipefs failed"

  # Create new XFS filesystem with NX_ROOT label
  # If we captured the old UUID, reuse it to maintain GRUB compatibility
  UUID_CHANGED="false"
  if [ -n "$OLD_UUID" ]; then
    printf '  ✓ Preserving filesystem UUID: %s\n' "$OLD_UUID" >/dev/console
    mkfs.xfs -f -L NX_ROOT -m uuid="$OLD_UUID" "$ROOT_DEV" >/dev/null 2>&1 || panic "NUTS Rescue: mkfs.xfs with UUID failed"
  else
    printf '  ! Could not read old UUID, creating new filesystem\n' >/dev/console
    mkfs.xfs -f -L NX_ROOT "$ROOT_DEV" >/dev/null 2>&1 || panic "NUTS Rescue: mkfs.xfs failed"
    UUID_CHANGED="true"
  fi

  printf '  ✓ Filesystem reformatted\n' >/dev/console

  # Try mounting again after reformat
  mount -t xfs "$ROOT_DEV" /tmp/root || panic "NUTS Rescue: mount after reformat failed"
fi

# Verify mount is successful before wiping
if ! grep -q "/tmp/root" /proc/mounts 2>/dev/null; then
  panic "NUTS Rescue: NX_ROOT not mounted, cannot proceed safely"
fi

printf '  ✓ NX_ROOT mounted\n' >/dev/console
printf '  ➜ Wiping current root contents...\n' >/dev/console

# Use a more robust method to wipe contents
cd /tmp/root || panic "NUTS Rescue: cannot cd to /tmp/root"
find . -mindepth 1 -maxdepth 1 -exec rm -rf {} + 2>/dev/null || {
  # Fallback: try simpler approach
  rm -rf /tmp/root/* /tmp/root/.* 2>/dev/null || true
}
cd / || true

printf '  ✓ Root partition cleared\n' >/dev/console

printf '  ➜ Decompressing and restoring system (this may take a while)...\n' >/dev/console

# Stream decompression directly to xfsrestore to avoid RAM/disk space issues
# xfsrestore reads from stdin when using '-' as the source
if ! zstd -d -c "$BACKUP_FILE" | xfsrestore - /tmp/root; then
  panic "NUTS Rescue: decompression or restore failed"
fi

printf '  ✓ System restored successfully\n' >/dev/console

# If we had to create a new UUID due to severe corruption, regenerate GRUB config
if [ -n "$UUID_CHANGED" ] && [ "$UUID_CHANGED" = "true" ]; then
  printf '  ➜ Regenerating GRUB configuration for new UUID...\n' >/dev/console

  # Get the new UUID
  NEW_UUID="$(blkid -s UUID -o value "$ROOT_DEV" 2>/dev/null || true)"

  if [ -n "$NEW_UUID" ]; then
    # Mount proc, sys, dev for chroot environment
    mount -t proc proc /tmp/root/proc 2>/dev/null || true
    mount -t sysfs sys /tmp/root/sys 2>/dev/null || true
    mount --bind /dev /tmp/root/dev 2>/dev/null || true

    # Update fstab if it uses UUID
    if [ -f /tmp/root/etc/fstab ]; then
      sed -i "s|UUID=[a-f0-9-]*\s\+/\s|UUID=$NEW_UUID / |g" /tmp/root/etc/fstab 2>/dev/null || true
    fi

    # Regenerate GRUB configuration
    chroot /tmp/root update-grub 2>/dev/null || true

    # Unmount chroot mounts
    umount /tmp/root/dev 2>/dev/null || true
    umount /tmp/root/sys 2>/dev/null || true
    umount /tmp/root/proc 2>/dev/null || true

    printf '  ✓ GRUB configuration updated\n' >/dev/console
  else
    printf '  ! Could not regenerate GRUB (UUID not readable)\n' >/dev/console
  fi
fi

printf '\n' >/dev/console

printf '  ➜ Syncing filesystems...\n' >/dev/console
sync
umount /tmp/root || panic "NUTS Rescue: umount root failed"
umount /tmp/home || panic "NUTS Rescue: umount home failed"
sync
printf '  ✓ All changes saved\n\n' >/dev/console

cat >/dev/console <<'EOF'
╔════════════════════════════════════════════════════════════════════════════╗
║                     RESCUE COMPLETED SUCCESSFULLY                          ║
╠════════════════════════════════════════════════════════════════════════════╣
║                                                                            ║
║  Your system has been restored from the backup.                            ║
║  The system will now reboot...                                             ║
║                                                                            ║
╚════════════════════════════════════════════════════════════════════════════╝

EOF

if [ -w /proc/sys/kernel/sysrq ]; then
  echo 1 > /proc/sys/kernel/sysrq 2>/dev/null || true
fi

if [ -w /proc/sysrq-trigger ]; then
  echo u > /proc/sysrq-trigger 2>/dev/null || true
  sleep 1
  echo b > /proc/sysrq-trigger 2>/dev/null || true
fi

reboot -f
